<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Ohm's Law Lab - Upper Scale</title>
<style>
body{margin:0;background:#111;overflow:hidden;font-family:sans-serif}
#ui{position:absolute;top:20px;left:20px;background:rgba(0,0,0,0.8);color:#fff;padding:20px;border-radius:10px;border:1px solid #444;pointer-events:none;min-width:180px}
.val{color:#00ff00;font-family:monospace;font-size:1.2rem;float:right}
.row{margin-bottom:10px;border-bottom:1px solid #222;padding-bottom:5px}
</style>
</head>
<body>

<div id="ui">
    <div class="row">Voltage: <span class="val">10 V</span></div>
    <div class="row">Box R: <span id="r-box" class="val">0 立</span></div>
    <div class="row">Total R: <span id="r-total" class="val">10 立</span></div>
    <div class="row" style="border:none">Current: <span id="curr" class="val" style="color:#ffee55">1.00 A</span></div>
</div>

<script type="importmap">
{"imports": {"three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"}}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0, 10, 15);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
scene.add(new THREE.AmbientLight(0xffffff, 0.6));
const sun = new THREE.DirectionalLight(0xffffff, 1);
sun.position.set(5, 10, 7);
scene.add(sun);

// --- Materials ---
const wood = new THREE.MeshStandardMaterial({color: 0x4a2c1d});
const metal = new THREE.MeshStandardMaterial({color: 0xaaaaaa, metalness: 0.8});
const plastic = new THREE.MeshStandardMaterial({color: 0x222222});

// --- Resistance Box ---
const box = new THREE.Mesh(new THREE.BoxGeometry(8, 2, 4), wood);
box.position.y = 1;
scene.add(box);

const knobs = [];
function createKnob(x, multi) {
    const group = new THREE.Group();
    group.position.set(x, 2, 0);
    
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.7, 0.7, 0.5, 32), plastic);
    const pointer = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.4), new THREE.MeshBasicMaterial({color: 0xffffff}));
    pointer.position.set(0, 0.26, -0.4);
    
    const pivot = new THREE.Group();
    pivot.add(body, pointer);
    pivot.userData = { value: 0, multi: multi };
    
    group.add(pivot);
    scene.add(group);
    knobs.push(pivot);
}
createKnob(-2.5, 100); createKnob(0, 10); createKnob(2.5, 1);

// --- Ammeter (Galvanometer) ---
const ammeter = new THREE.Group();
ammeter.position.set(0, 0, -6);

// Body
const base = new THREE.Mesh(new THREE.BoxGeometry(8, 6, 2), plastic);
base.position.y = 3;
ammeter.add(base);

// Scale Face
const canvas = document.createElement('canvas');
canvas.width = 1024; canvas.height = 1024;
const ctx = canvas.getContext('2d');

// Draw Scale in 0 to PI region (Top Half)
const cx = 512, cy = 600, radius = 400;
ctx.strokeStyle = "black";
ctx.fillStyle = "black";
ctx.textAlign = "center";
ctx.lineCap = "round";

// Background face
ctx.fillStyle = "white";
ctx.beginPath(); ctx.arc(cx, cy, radius + 100, 0, Math.PI, true);
ctx.fill();

// Main Arc
ctx.lineWidth = 5;
ctx.beginPath(); ctx.arc(cx, cy, radius, Math.PI, 0); ctx.stroke();

// Marks 0 to 1.0
for (let i = 0; i <= 10; i++) {
    const val = i / 10;
    // Map val 0->1 to Angle PI -> 0
    const angle = Math.PI - (val * Math.PI);
    
    const x1 = cx + radius * Math.cos(angle);
    const y1 = cy - radius * Math.sin(angle);
    const x2 = cx + (radius + 40) * Math.cos(angle);
    const y2 = cy - (radius + 40) * Math.sin(angle);
    
    ctx.lineWidth = 6;
    ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
    
    // Labels
    ctx.font = "bold 45px Arial";
    const lx = cx + (radius + 80) * Math.cos(angle);
    const ly = cy - (radius + 80) * Math.sin(angle);
    ctx.fillText(val.toFixed(1), lx, ly + 15);
}

// Fine increments (0.02)
for (let i = 0; i <= 50; i++) {
    const angle = Math.PI - (i / 50 * Math.PI);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx + radius * Math.cos(angle), cy - radius * Math.sin(angle));
    ctx.lineTo(cx + (radius + 20) * Math.cos(angle), cy - (radius + 20) * Math.sin(angle));
    ctx.stroke();
}

ctx.font = "40px Arial";
ctx.fillText("AMPERES (A)", cx, cy - 200);

const texture = new THREE.CanvasTexture(canvas);
const faceGeo = new THREE.PlaneGeometry(7, 5);
const faceMat = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
const face = new THREE.Mesh(faceGeo, faceMat);
face.position.set(0, 3.5, 1.01);
ammeter.add(face);

// Needle
const needlePivot = new THREE.Group();
needlePivot.position.set(0, 0.6, 1.05); // Centered relative to the arc on face
ammeter.add(needlePivot);

const needleMesh = new THREE.Mesh(
    new THREE.BoxGeometry(0.08, 4.5, 0.01),
    new THREE.MeshBasicMaterial({ color: 0xff0000 })
);
needleMesh.position.y = 2.25; // Offset so it rotates around its base
needlePivot.add(needleMesh);

scene.add(ammeter);

// --- Simulation Logic ---
let targetAngle = Math.PI / 2; // Default to 1.0A (vertical for math circle is PI/2)

function updateSimulation() {
    let rBox = 0;
    knobs.forEach(k => rBox += k.userData.value * k.userData.multi);
    
    const voltage = 10;
    const rInternal = 10;
    const rTotal = rBox + rInternal;
    const current = voltage / rTotal; // Max is 1.0 when rBox is 0

    document.getElementById('r-box').innerText = rBox + " 立";
    document.getElementById('r-total').innerText = rTotal + " 立";
    document.getElementById('curr').innerText = current.toFixed(3) + " A";

    // MAPPING:
    // Current 0.0 -> Angle PI (Left)
    // Current 1.0 -> Angle 0 (Right)
    // Formula: PI - (current * PI)
    // However, Three.js Z rotation 0 is UP. 
    // To match the canvas:
    // Current 0.0 -> +90 deg (Left)
    // Current 1.0 -> -90 deg (Right)
    targetAngle = (Math.PI / 2) - (current * Math.PI);
}

// --- Interaction ---
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

window.addEventListener('mousedown', (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    
    const intersects = raycaster.intersectObjects(knobs, true);
    if (intersects.length > 0) {
        let knob = intersects[0].object;
        while(knob.parent && !knob.userData.multi) knob = knob.parent;
        
        knob.userData.value = (knob.userData.value + 1) % 10;
        knob.rotation.y = -(knob.userData.value * (Math.PI * 2 / 10));
        updateSimulation();
    }
});

function animate() {
    requestAnimationFrame(animate);
    // Smooth magnetic damping for needle
    needlePivot.rotation.z += (targetAngle - needlePivot.rotation.z) * 0.1;
    controls.update();
    renderer.render(scene, camera);
}

updateSimulation();
animate();

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
